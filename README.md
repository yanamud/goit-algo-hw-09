**Опис завдання:**

Надано набір монет [50, 25, 10, 5, 2, 1] та необхіно визначити оптимальний спосіб видачі решти покупцеві.

Для реалізації даного завдання розроблено дві функції, які повертають словник із кількістю монет кожного номіналу, що використовуються для формування решти покупцеві:
  - Функція жадібного алгоритму (find_coins_greedy)
  
  - Функція динамічного програмування (find_min_coins).
  
Та отримано наступні результати:
 
  - Оптимальний спосіб видачі решти 113 покупцеві за допомогою жадібного алгоритму:
  
{50: 2, 10: 1, 2: 1, 1: 1}

  - Оптимальний спосіб видачі решти 113 покупцеві за допомогою динамічного програмування:
  
{50: 2, 10: 1, 2: 1, 1: 1}

При порівянні результатів видно, що вони ідентичні. Це пояснюється в першу чергу тим, що надано лише один параметр (номінал монет) для визначення оптимальної кількості монет.
Однак зі збільшенням кількості параметрів можна отримати різні оптимальні варіанти, оскільки:

- жадібний алгоритм може знайти лише придатне, але не оптимальне рішення, тому що починає з вибору елемента з найбільшим співвідношенням наданих параметрів і на кожному наступному кроці вибирає найкращий локальний варіант, сподіваючись, що це приведе до оптимального глобального рішення.

- динамічний алгоритм гарантує знаходження оптимального рішення, тому що розбиває початкову задачу на менші підзадачі, розв'язує їх і зберігає результати для використання у майбутньому, щоб уникнути повторного розв'язання цих підзадач.

Також проведено порівняння ефективності жадібного алгоритму та алгоритму динамічного програмування.

Для цього було рандомно вибрано три числа (можлива решта покупцеві):
- перше число в діапазоні від 1 до 10 (small data)
- друге число в діапазоні від 10 до 100 (medium data)
- третє число в діапазоні від 100 до 1000 (big data)
та знайдено оптимальний спосіб видачі решти покупцеві.


| Algorithm               | Time small data      | Time medium data     | Time big data        |
:------------------------ | :------------------- | :------------------- | :------------------- |
| Жадібний алгоритм       | 0.00001              | 0.00001              | 0.00001              |
| Динамічне програмування | 0.00002              | 0.00013              | 0.00384              |


Оскільки надано відсортований від найбільшого до найменшого номіналу список монет, то при використанні 
жадібного алгоритму не витрачається час на сортування, а лише відбувається проходження через список монет для підрахунку оптимальної кількості монет. 
Тому в результаті маємо однаковий час знаходження оптимального списку монет незалежно від розміну решти.

Оскільки при використанні динамачного алгоритму створюється двомірна таблиця, яка заповнюється знизу вгору, починаючи з нульових значень для випадків, 
коли в нас немає решти, то оптимальна кількість монет, яку можна отримати для основної задачі, знаходиться в останній клітинці цієї таблиці.
Тому при збільшенні розміру решти збільшується час побудову таблиці, її заповнення та перегляду значення в останній клітинці.

Отже, враховуючи вище викладене, для вирішення конкретного завдання більш ефективнішим є використання жадібного алгоритму, оскільки витрачається меньше часу на отримання оптимального рішення і з великою ймовірність можна стверджувати, що воно буле гарантовано вірним. 
